%%
%% Generate 2 * param.nDisparity symmetric directional Prewitt filters.
%% The filters are twice as high as the height of the EPI. 
%%
%% The gradient of each filter along the x, and y directions is returned in gx,
%% and gy respectively. The slope in m.
%%
function [F, m, gx, gy] = genFilters(param)

  n = ceil(param.nDisparity/2);
  s = expspace( -param.maxAbsDisparity, 0, -1, n);
  
  h = 2 * param.szEPI(1) + 1;
  w = ceil(max(h, max(abs(s)) * h + 2));
  if mod(w, 2) == 0
    w = w + 1;
  end
  xc = ceil(w/2);
  yc = ceil(h/2);

  F = zeros(h, w, n * 2 - 1);
  gx = zeros(1, n * 2 - 1);
  gy = zeros(1, n * 2 - 1);
  m = zeros(1, n * 2 - 1);

  [X, Y] = meshgrid(1:w, 1:h);
  
  for i = 1:n
    x = [xc + s(i) * (yc - 1) xc + s(i) * (yc - h)];
    y = [1 h];

    bwPos = zeros(h, w);
    bwPos = wu( bwPos, x(1) - 1, y(1), x(2) - 1, y(2));
    bwPos = bwPos / sum(sum(bwPos));

    bwNeg = zeros(h, w);
    bwNeg = wu( bwNeg, x(1) + 1, y(1), x(2) + 1, y(2));
    bwNeg = (bwNeg / sum(sum(bwNeg))) .* -1;

    F(:, :, i) = bwNeg + bwPos;

    % Calculate the slope and the gradients of the filters
    dy = h - 1;
    dx = x(1) - x(2);
    dm = 1 ./ sqrt(dx.^2 + dy.^2);
    gy(i) = -dx .* dm;
    gx(i) = dy .* dm;
    m(i) = dy ./ dx;
  end

  % the next n filters are generated by flipping the existing ones
  F(:, :, n+1:end) = fliplr(F(:, :, n-1:-1:1)) .* -1; 
  gx(n+1:end) = gx(n-1:-1:1);
  gy(n+1:end) = -gy(n-1:-1:1);
  m(n+1:end) = -m(n-1:-1:1);
end


